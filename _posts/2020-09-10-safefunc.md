---
layout: post
title: 安全函数
date: 2020-09-10
Author: xuxeu
categories: 
tags: [编程杂谈]
comments: true
typora-root-url: ..
---

> 公司的大佬说之前某大厂为了安全函数的替换耗资10亿美金。可想安全很重要，安全函数很重要，对于我们做系统软件的来说很重要。
> 

为什么要替换成安全函数，这里面就涉及到了一种漏洞攻击，**缓冲区溢出攻击**。

缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序会检查数据长度，而且并不允许输入超过缓冲区长度的字符。但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。操作系统所使用的缓冲区，又被称为**“堆栈”**，在各个操作进程之间，指令会被临时储存在“堆栈”当中，“堆栈”也会出现缓冲区溢出。缓冲区溢出攻击是利用缓冲区溢出漏洞所进行的攻击行动。利用缓冲区溢出攻击，可以导致程序运行失败、系统关机、重新启动等后果。

缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，**在函数返回时改变返回程序的地址**，让其跳转到任意地址，带来的危害一种是**程序崩溃导致拒绝服务**分段错误（Segmentation fault），另外一种就是**跳转并且执行一段恶意代码**，比如得到shell，然后为所欲为。

C语言没有提供字符串类型，字符串以字符数组的形式出现，C标准库提供了一些操作字符串的函数，主要有：strcmp 字符串比较函数，strcpy 字符串拷贝函数， strlen 字符串测长函数， strcat字符串连接函数，sprintf格式化字符串拷贝函数等等。**因为字符串就是以‘\0’结束的一段内存**，这些函数**实质上也就是操作内存的函数**。

**也就是说，安全函数和非安全函数最大的差异就是：为了防止堆栈溢出，安全函数多了一个确定buff长度的参数。**

**举个例子：**

非安全函数：

```c
头文件：
#include <string.h>
函数原型：
char *strcpy(char *dest, const char *src);
函数说明：
把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间。
src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。
```

安全函数：

```c
头文件：
#include <string.h>
函数原型：
char *strncpy(char *dest, const char *src, size_t n);
函数说明：
把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间。最多复制n个字符。
src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。
```

