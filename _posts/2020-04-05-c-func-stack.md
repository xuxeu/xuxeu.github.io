---
layout: post
title: C函数栈层次分析
date: 2020-04-05
Author: xuxeu
categories: 
tags: [编程杂谈]
comments: true
typora-root-url: ..
---

> 该文摘抄自segmentfault中的RdouTyping。

在计算机系统中，内存空间中的栈主要用于保存函数的参数，返回值，返回地址，本地变量等。

一切的函数调用都要将不同的数据，地址压入或者弹出栈。因此为了更好的理解函数调用，我们需要先来看看栈是怎么工作的。

### 栈是什么？

简单来说，栈是一种LIFO形式的数据结构，所有的数据都是后进先出。这种形式的数据结构正好满足我们调用函数的方式：父函数调用子函数，父函数在前，子函数在后；返回时，子函数先返回，父函数后返回。

栈支持两种基本操作，push和pop。push将数据压入栈中，pop将栈中的数据弹出并存储到指定寄存器或者内存中。

这里是一个push操作的例子。假设我们有一个栈，其中黄色部分是已经写入数据的区域，绿色部分是还未写入数据的区域。

现在我们将0x50压入栈中：

push $0x50    //将0x50的压入栈
![push](/images/2020-04-05-c-func-stack/push.png)


我们再来看看pop操作的例子：

pop    //将0x50弹出栈
![pop](/images/2020-04-05-c-func-stack/pop.png)


需要注意两点：

1.栈的生长方向是从高地址到低地址的，栈是向下生长的。

2.pop操作后，栈中的数据并没有被清空，只是该数据我们无法直接访问。

### 栈层次是什么？

栈层次，也就是stack frame，本质就是一种栈。只是这种栈专门用来保存函数调用过程中的各种信息(参数，返回地址，本地变量等)。栈层次有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，sp(栈指针)就是一直指向栈顶的。在x86-32bit中，我们用%ebp指向栈底，也就是基址指针；用%esp指向栈顶，也就是栈指针。

下面是一个栈层次示意图：
![push](/images/2020-04-05-c-func-stack/stack.png)



栈层次
一般来说，我们将%ebp到%esp之间的区域当作栈层次(也有人认为该从函数参数开始，不过这不影响分析)。并不是整个栈空间只有一个栈层次，每调用一个函数，就会生成一个新的栈层次。在函数调用过程中，我们将调用函数称为“调用者caller”，将被调用的函数称为“被调用者callee”。

在这个过程中:

1.调用者需要知道在哪里获取被调用者返回的值；

2.被调用者需要知道传入的参数在哪里，返回的地址在哪里

3.被调用者返回后，%ebp，%esp等寄存器的值应该和调用前一致。

因此，我们需要栈来保存这些参数。

### 函数调用

我们直接通过实例来看函数是如何调用的。这是一个有参数但没有调用任何函数的简单函数，我们假设它被其他函数调用。
![push](/images/2020-04-05-c-func-stack/c_souce.png)

c源码
对于这个函数，当调用时，MyFunction()的汇编代码大致如下：
![push](/images/2020-04-05-c-func-stack/asm.png)



汇编
然后，我们来看看此时的栈是什么样的：
![push](/images/2020-04-05-c-func-stack/调用栈层次.png)

### 调用栈层次

此时，调用者做了2件事：

1.将被调用函数的参数按照从右到左的顺序压入栈中。

2.将返回地址压入栈中。

这2件事都是调用者负责的，因此压入的栈属于调用者的栈层次。

被调用者也做了2件事：

1.将老的(调用者的)%ebp压入栈，此时%esp指向它。

2.将%esp的值赋给%ebp，%ebp就有了新的值，它也指向存放老%ebp的栈空间。这时，它成为了函数MyFunction()栈层次的栈底。

这样，我们就保存了调用者函数的%ebp，并且建立了一个新的栈层次。

在%ebp更新后，我们先分配一块0x12字节的空间用于存放本地变量，这步一般都是用sub或者mov指令实现。在这里使用的是movl。通过使用mov配合-4(%ebp),-8(%ebp)和-12(%ebp)我们便可以给a,b和c赋值了。

### 函数返回

上面讲的都是函数的调用过程，我们现在来看看函数是如何返回的。从下面这个例子我们可以看出，和调用函数时正好相反。当函数完成自己的任务后，它会将%esp移到%ebp处，然后再弹出旧的%ebp的值到%ebp。这样，%ebp就恢复到了函数调用前的状态了。

![push](/images/2020-04-05-c-func-stack/c源码.png)
c源码
![push](/images/2020-04-05-c-func-stack/汇编.png)
汇编
我们注意到最后有一个ret指令，这个指令相当于pop+jump。它首先将数据（返回地址）弹出栈并保存到%eip中，然后处理器根据这个地址无条件跳到相应位置获取新的指令。

### 总结

C函数的调用过程，以及栈层次的分析大概就是这样。重点在于：

1.参数和返回地址的压栈在于调用者

2.被调用函数中的变量等的压栈在于被调用者

3.如何保存以及还原%ebp和%esp。

### 小尾巴

出差必备：
买火车票、高铁票、机票，订酒店都打9折的出行工具TRIP,[点击注册](https://h5.itrip.world/#/register/6tpd1Z)

优惠购物：
你还在傻傻的原价淘宝吗？来这里领取内部优惠券，折扣力度非常大！[点击注册](http://url.cn/5KRkJq6)，注册需要邀请码UWD9Q9E。